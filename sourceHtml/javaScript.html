<h2>Змінні</h2>
<r>
    <dfn>var</dfn><br>
    В коді:<br>
    <code>var name;<br>var name = "Myhailo";</code> <br>
    Область видимості var: або локальна (якщо оголошення всередині функції) або глобальна
    Змінні var можуть бути оголошені повторно або оновлені.
    Підняття var, тобто змінна, може бути оголошена після її використання в коді (тоді вона спочатку ініціалізується
    зі значенням undefind)
   
</p>
<br>
<p>
    <dfn>let</dfn><br>
    В коді:<br>
    <code>let name;<br>let name = "Myhailo";</code> <br>
    let виступає як покращення оголошення через var, і до того ж вирішує проблему з var, про яку ми щойно говорили
    let має блочну область видимості. Блок це фрагмент коду, обмежений фігурними дужками {}
    Змінні let можуть бути оновлені, але не оголошені повторно
    Підняття let може підніматися як і var, але на відміну від var-змінних, які ініціалізуються як undefined,
    ключове слово для let не ініціалізується.
    Так що якщо ви спробуєте використовувати змінну let до того, як її буде оголошено, то отримаєте помилку звернення
    до змінної ReferenceError.
</p>
<br>
<p>
    <dfn>const</dfn><br>
    В коді:<br>
    <code>const name;<br>const name = "Myhailo";</code> <br>
    Змінні, оголошені через const зберігають постійні значення.
    const має блокову область видимості як і let-змінні.
    Змінні const не можуть бути ні оновлені, ні оголошені повторно
    Підняття const, так само, як і let, оголошення через const переміщуються вгору, але не ініціалізуються.
</p>

<h2>Типи даних</h2>
<p>
    Всі використовувані дані в JavaScript мають певний тип. JavaScript має вісім типів даних:<br>
    <ul>
        <li>String: представляє рядок</li>
        <li>Number: представляє числове значення</li>
        <li>BigInt: призначений для представлення дуже великих цілих чисел</li>
        <li>Boolean: представляє логічне значення true або false</li>
        <li>Undefined: представляє одне спеціальне значення - undefined та вказує, що значення не встановлено</li>
        <li>Null: представляє одне спеціальне значення - null та вказує на відсутність значення</li>
        <li>Symbol: представляє унікальне значення, яке часто застосовується для звернення до властивостей складних об'єктів</li>
        <li>Object: представляє комплексний об'єкт</li>
    </ul>
    За допомогою оператора <dfn>typeof</dfn> отримати тип змінної.
</p>
<h2>Функції</h2>
<p>
    <dfn>Функція JavaScript</dfn> - це спеціальний тип об'єктів, що дозволяє формалізувати засобами мови певну логіку поведінки і 
    обробки даних.

    <h3>Оголошення функцій</h3>
    <h4>Функції типу "function declaration statement"</h4>
    Оголошення функції (function definition або function declaration, або function statement) складається з ключового слова 
    function і наступних частин:
    <ul>
        <li>Назва функції.</li>
        <li>Список параметрів (приймаються функцією) обрамлены у круглі дужки () та розділених комами.</li>
        <li>Інструкції, які будуть виконані після виклику функції, обрамлююьбся фігурими дужками { }.</li>
    </ul>
    Приклад:<br>
    <code>
        function square(number) {<br>
            return number * number;<br>
          }<br>
    </code>
    <h4>Функції типу "function definition expression"</h4>
    Функція виду "function declaration statement" за синтаксисом є інструкцією (statement), ще функція може бути виду "function 
    definition expression". Така функція може бути анонімною (вона не має імені). Наприклад, функція square може бути викликана так:
    <br><code>var square = function(number) { return number * number; };</code>
    
    <h3>Область видимості функцій</h3>
    Змінні, що оголошені у функції не можуть бути доступними де-небудь поза цією функцією, тому змінні (які потрібні саме для функції) 
    оголошують тільки в scope функції. При цьому функція має доступ до всіх змінних та функцій, оголошених усередині її scope. Тобто 
    функція оголошена у глобальному scope має доступ до всіх змінних у глобальному scope. Функція оголошена всередині іншої функції 
    має доступ до всіх змінних батьківської функції та інших змінних, до яких ця батьківська функція має доступ.
    
    <h3>Масив function name (arguments)</h3>
    При необхідності ми можемо отримати всі передані параметри через глобально доступний масив arguments. При цьому навіть 
    не важливо, що при визначенні
    функції ми не вказали жодних параметрів, ми все одно можемо їх передати і отримати їх значення через масив arguments.
    
    <h3>Невизначена кількість параметрів</h3>
    За допомогою оператора ... (багатокрапка/spread) ми можемо вказати, що з допомогою параметра можна передати змінну кількість 
    значень, наприклад function display(season, ...temps)
    У цьому випадку другий параметр ...temps вказує, що замість нього можна передати різну кількість значень. У самій функції 
    temps фактично представляє масив переданих значень, які ми можемо отримати. При цьому незважаючи на це, при виклику функції 
    до неї передається не масив, а окремі значення.
    
    <h3>Функция может выступать в качестве параметра другой функции</h3>
    Возвращение функции из функции возмжно. Функция будет выглядеть примерно так: 
    <code><br>
        function menu(n){<br>
    		if(n==1) return function(x, y){ return x + y;}<br>
	    }
    </code><br>
    и вызов тогда:<br>
    <code>
        const action = menu(1);         // выбираем первый пункт - сложение<br>
        const result = action(2, 5);    // выполняем функцию и получаем результат в константу result<br>
        console.log(result); 
    </code><br>
    <h3>Замикання (closure)</h3>
    Замикання (closure) є конструкцією, коли функція, створена в одній області видимості, запам'ятовує своє лексичне оточення навіть 
    у тому випадку, коли вона виконується поза своєю областю видимості
    Замикання технічно включає три компоненти:
    <ul>
        <li>Зовнішня функція, яка визначає деяку область видимості і в якій визначені деякі змінні - лексичне оточення</li>
        <li>Змінні (лексичне оточення), які визначені у зовнішній функції</li>
        <li>Вкладена функція, яка використовує ці змінні</li>
    </ul>
    Замикання можуть бути використані для створення незалежних один від одного лічильників, різних валідаторів (на поля введення 
    імені, телефону та інше) та для зберігання різних ключів кодування або кодування даних на клієнті.
    <h3>Самовизовні функції</h3>
    Ми також можемо створити такі функції, які будуть викликатись відразу при визначенні. Такі функції ще називають 
    <dfn>Immediately Invoked Function Expression (IIFE)</dfn>
    Подібні функції полягають у дужках і після визначення функції йде в дужках передача параметрів. Приклад:<br>
    <code>
        (function(){<br>
            console.log("Привет мир");<br>
        }());<br>
    </code>
    <h3>Паттерн "Модуль"</h3>
    Паттерн "Модуль" базується на замикання і складається з двох компонентів: зовнішня функція, яка визначає лексичне оточення, 
    і повертається набір внутрішніх функцій, які мають доступ до цього оточення.
    <h3>Рекурсивні функції</h3>
    Їхня суть полягає в тому, що функція викликає саму себе. Обов'язково має бути умова завершення рекурсії.
    <h3>Перевизначення функцій</h3>
    Функції мають можливість для перевизначення поведінки. Перевизначення відбувається за допомогою присвоєння анонімної функції 
    змінної, яка називається так само, як і функція, що перевизначається.
    <h3>Передача за посиланням</h3>
    Об'єкти та масиви передаються за посиланням до функції. Тобто функція отримує сам об'єкт або масив, а не їхню копію 
    (точніше посилання на даний об'єкт у пам'яті)
    <h3>Стрілочна функція</h3>
    Щоб повернути значення зі стрілочної функції, нам достатньо вказати його після стрілки.
    Особливо слід зупинитися у разі, коли стрілочна функція повертає об'єкт:<br>
    <code>let user = (userName, userAge) => ({name: userName, age: userAge});</code><br>
    А якщо треба повернути результат, застосовується оператор return, як у звичайній функції.
</p>

<h2>Логічні оператори</h2>
<p>

</p>