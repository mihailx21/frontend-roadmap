<section>
    <h2>Змінні</h2>
    <dfn>var</dfn>
    <p>
        В коді:<br>
        <code>var name;<br>var name = "Myhailo";</code> <br>
        Область видимості var: або локальна (якщо оголошення всередині функції) або глобальна
        Змінні var можуть бути оголошені повторно або оновлені.
        Підняття var, тобто змінна, може бути оголошена після її використання в коді (тоді вона спочатку ініціалізується
        зі значенням undefind)
    </p>
    <dfn>let</dfn>
    <p>
        В коді:<br>
        <code>let name;<br>let name = "Myhailo";</code> <br>
        let виступає як покращення оголошення через var, і до того ж вирішує проблему з var, про яку ми щойно говорили
        let має блочну область видимості. Блок це фрагмент коду, обмежений фігурними дужками {}
        Змінні let можуть бути оновлені, але не оголошені повторно
        Підняття let може підніматися як і var, але на відміну від var-змінних, які ініціалізуються як undefined,
        ключове слово для let не ініціалізується.
        Так що якщо ви спробуєте використовувати змінну let до того, як її буде оголошено, то отримаєте помилку звернення
        до змінної ReferenceError.
    </p>
    <dfn>const</dfn>
    <p>
        В коді:<br>
        <code>const name;<br>const name = "Myhailo";</code> <br>
        Змінні, оголошені через const зберігають постійні значення.
        const має блокову область видимості як і let-змінні.
        Змінні const не можуть бути ні оновлені, ні оголошені повторно
        Підняття const, так само, як і let, оголошення через const переміщуються вгору, але не ініціалізуються.
    </p>
</section>

<section>
    <h2>Типи даних</h2>
    <p>
        Всі використовувані дані в JavaScript мають певний тип. JavaScript має вісім типів даних:
    </p>
    <ul>
        <li>String: представляє рядок</li>
        <li>Number: представляє числове значення</li>
        <li>BigInt: призначений для представлення дуже великих цілих чисел</li>
        <li>Boolean: представляє логічне значення true або false</li>
        <li>Undefined: представляє одне спеціальне значення - undefined та вказує, що значення не встановлено</li>
        <li>Null: представляє одне спеціальне значення - null та вказує на відсутність значення</li>
        <li>Symbol: представляє унікальне значення, яке часто застосовується для звернення до властивостей складних об'єктів</li>
        <li>Object: представляє комплексний об'єкт</li>
    </ul>
    <p>
        За допомогою оператора <dfn>typeof</dfn> отримати тип змінної.
    </p>
</section>
<section>
    <h2>Цикли</h2>
    <p>
        <h3>while</h3>
        Цикл при цьому виконується до тих пор, поки некоторое умова істинно
    </p>
    <p>
        <h3>do ... while</h3>
        У циклі do спочатку виконується код циклу, а потім відбувається перевірка умов в інструкціях while
    </p>
    <p>
        <h3>for ... in</h3>
        Цикл for..in призначений головним чином для перебора об'єктів
    </p>
    <p>
        <h3>for ... of</h3>
        Цикл for...of призначений для перебору набору даних (строк, масивів і т.п.)
    </p>
</section>
<section>
    <h2>Об'єкти</h2>
    <p>
        Кожен об’єкт може зберігати властивості, які описують його стан, і методи, які описують його поведінку
        Після створення об'єкта ми можемо визначити його властивості. Щоб визначити властивість, необхідно після назви 
        об’єкта через точку вказати ім’я властивості та отримати його значення
        Методи об'єкта визначають його поведінку або дії, які він виробляє. Методи представляють собою функції.
        Існує також альтернативний спосіб визначення властивостей і методів за допомогою синтаксису масивів - <br> user["name"] = "Tom"; <br>
        Также следует отметить, что названия свойств и методов объекта всегда представляют строки. Бывают случаи, где заключение названия 
        в строку могут помочь. Например, 
        если название свойства состоит из двух слов, разделенных пробелом. Только в этом случае для обращении к подобным свойствам и 
        методам мы должны использовать 
        синтаксис массивов
    </p>
    <h3>Динамічне визначення імен властивостей і методів</h3>
    <p>
        Синтаксис масивів відкриває нам іншу можливість - визначення імені властивості вне об'єкта. <br>
        <code>
        const prop1  = "name"; <br>
        const prop2  = "age"; <br>
        let tom = {     <br>
               [prop1]: "Tom", <br>
               [prop2]: 37 <br>
        }; <br>
        </code>
        Завдяки цьому, наприклад, можна динамічно створювати об’єкти з довільними назвами властивості <br>
        <code>
            function createObject(propName, propValue){ <br>
                return { <br>
                        [propName]: propValue, <br>
                        print(){  <br>
                            console.log(`${propName}: ${propValue}`); <br>
                        } <br>
                }; <br>
                }   <br>
                let person = createObject("name", "Tom"); <br>
                person.print();     // name: Tom <br>
             
                let book = createObject("title", "JavaScript Reference"); <br>
                book.print();   // title: JavaScript Reference  <br>
        </code>
    </p>
    <p>
        <h3>Видалення властивостей</h3>
        Однак ми також можемо видалити властивості та методи за допомогою оператора delete. І як і в разі додавання ми можемо видалити властивості двома способами.
        Перший спосіб - використання позначення точки: <br>
        delete object.властивість <br>
        Либо використовувати синтаксис масивів: <br>
        delete object["властивість"]
    </p>
</section>
<section>
    <h2>Функції</h2>
    <p>
        <dfn>Функція JavaScript</dfn> - це спеціальний тип об'єктів, що дозволяє формалізувати засобами мови певну логіку поведінки і 
        обробки даних.
    </p>

    <h3>Оголошення функцій</h3>
    <h4>Функції типу "function declaration statement"</h4>
    Оголошення функції (function definition або function declaration, або function statement) складається з ключового слова 
    function і наступних частин:
    <ul>
        <li>Назва функції.</li>
        <li>Список параметрів (приймаються функцією) обрамлены у круглі дужки () та розділених комами.</li>
        <li>Інструкції, які будуть виконані після виклику функції, обрамлююьбся фігурими дужками { }.</li>
    </ul>
    Приклад:<br>
    <code>
        function square(number) {<br>
            return number * number;<br>
          }<br>
    </code>
    <h4>Функції типу "function definition expression"</h4>
    Функція виду "function declaration statement" за синтаксисом є інструкцією (statement), ще функція може бути виду "function 
    definition expression". Така функція може бути анонімною (вона не має імені). Наприклад, функція square може бути викликана так:
    <br><code>var square = function(number) { return number * number; };</code>
    
    <h3>Область видимості функцій</h3>
    Змінні, що оголошені у функції не можуть бути доступними де-небудь поза цією функцією, тому змінні (які потрібні саме для функції) 
    оголошують тільки в scope функції. При цьому функція має доступ до всіх змінних та функцій, оголошених усередині її scope. Тобто 
    функція оголошена у глобальному scope має доступ до всіх змінних у глобальному scope. Функція оголошена всередині іншої функції 
    має доступ до всіх змінних батьківської функції та інших змінних, до яких ця батьківська функція має доступ.
    
    <h3>Масив function name (arguments)</h3>
    При необхідності ми можемо отримати всі передані параметри через глобально доступний масив arguments. При цьому навіть 
    не важливо, що при визначенні
    функції ми не вказали жодних параметрів, ми все одно можемо їх передати і отримати їх значення через масив arguments.
    
    <h3>Невизначена кількість параметрів</h3>
    За допомогою оператора ... (багатокрапка/spread) ми можемо вказати, що з допомогою параметра можна передати змінну кількість 
    значень, наприклад function display(season, ...temps)
    У цьому випадку другий параметр ...temps вказує, що замість нього можна передати різну кількість значень. У самій функції 
    temps фактично представляє масив переданих значень, які ми можемо отримати. При цьому незважаючи на це, при виклику функції 
    до неї передається не масив, а окремі значення.
    
    <h3>Функция может выступать в качестве параметра другой функции</h3>
    Возвращение функции из функции возмжно. Функция будет выглядеть примерно так: 
    <code><br>
        function menu(n){<br>
    		if(n==1) return function(x, y){ return x + y;}<br>
	    }
    </code><br>
    и вызов тогда:<br>
    <code>
        const action = menu(1);         // выбираем первый пункт - сложение<br>
        const result = action(2, 5);    // выполняем функцию и получаем результат в константу result<br>
        console.log(result); 
    </code><br>
    <h3>Замикання (closure)</h3>
    Замикання (closure) є конструкцією, коли функція, створена в одній області видимості, запам'ятовує своє лексичне оточення навіть 
    у тому випадку, коли вона виконується поза своєю областю видимості
    Замикання технічно включає три компоненти:
    <ul>
        <li>Зовнішня функція, яка визначає деяку область видимості і в якій визначені деякі змінні - лексичне оточення</li>
        <li>Змінні (лексичне оточення), які визначені у зовнішній функції</li>
        <li>Вкладена функція, яка використовує ці змінні</li>
    </ul>
    Замикання можуть бути використані для створення незалежних один від одного лічильників, різних валідаторів (на поля введення 
    імені, телефону та інше) та для зберігання різних ключів кодування або кодування даних на клієнті.
    <h3>Самовизовні функції</h3>
    Ми також можемо створити такі функції, які будуть викликатись відразу при визначенні. Такі функції ще називають 
    <dfn>Immediately Invoked Function Expression (IIFE)</dfn>
    Подібні функції полягають у дужках і після визначення функції йде в дужках передача параметрів. Приклад:<br>
    <code>
        (function(){<br>
            console.log("Привет мир");<br>
        }());<br>
    </code>
    <h3>Паттерн "Модуль"</h3>
    Паттерн "Модуль" базується на замикання і складається з двох компонентів: зовнішня функція, яка визначає лексичне оточення, 
    і повертається набір внутрішніх функцій, які мають доступ до цього оточення.
    <h3>Рекурсивні функції</h3>
    Їхня суть полягає в тому, що функція викликає саму себе. Обов'язково має бути умова завершення рекурсії.
    <h3>Перевизначення функцій</h3>
    Функції мають можливість для перевизначення поведінки. Перевизначення відбувається за допомогою присвоєння анонімної функції 
    змінної, яка називається так само, як і функція, що перевизначається.
    <h3>Передача за посиланням</h3>
    Об'єкти та масиви передаються за посиланням до функції. Тобто функція отримує сам об'єкт або масив, а не їхню копію 
    (точніше посилання на даний об'єкт у пам'яті)
    <h3>Стрілочна функція</h3>
    Щоб повернути значення зі стрілочної функції, нам достатньо вказати його після стрілки.
    Особливо слід зупинитися у разі, коли стрілочна функція повертає об'єкт:<br>
    <code>let user = (userName, userAge) => ({name: userName, age: userAge});</code><br>
    А якщо треба повернути результат, застосовується оператор return, як у звичайній функції.
</section>

<h2>Логічні оператори</h2>
<section>
    <p>    
        В JavaScript існує чотири логічні оператори: || (АБО), && (І), ! (НЕ), ?? (оператор null-об’єднання).
        Хоча вони називаються “логічними”, вони можуть бути застосовані до значень будь-якого типу, не тільки булевих. 
        Їх результати також можуть бути будь-якого типу.
    </p>
    <h3>|| (АБО)</h3>
    <p>
        Оператор “АБО” представлений двома символами вертикальної лінії: <br>
        <code>result = a || b;</code> <br>
        У класичному програмуванні логічний оператор АБО призначений для маніпулювання лише булевими значеннями. 
        Якщо будь-який з його аргументів означає true, повертається true, інакше повертається false.
        У JavaScript цей оператор складніший і потужніший. Але спочатку подивимося, що відбувається з булевими значеннями.
        Є чотири можливі логічні комбінації: <br>
        <code>
            alert( true || true );   // true    <br>
            alert( false || true );  // true    <br>
            alert( true || false );  // true    <br>
            alert( false || false ); // false   <br>
        </code>
        Як бачимо, результат завжди true, за винятком випадку, коли обидва операнди false.
        Якщо операнд не є булевим, він перетворюється на булевий для обчислення.
        Наприклад, число 1 розглядається як true, число 0 — як false.
        У більшості випадків АБО || використовується в інструкціях if, щоб перевірити, чи є будь-яка із заданих умов true.
        Якщо у нас є декілька змінних розділених операндом ||(АБО) то оператор АБО || робить наступне:
        <ul>
            <li>Обчислює операнди зліва направо.</li>
            <li>Перетворює значення кожного операнда на булеве. Якщо результат true, зупиняється і повертає початкове значення цього операнда.</li>
            <li>Якщо всі операнди були обчисленні (тобто усі були false), повертає останній операнд.</li>
        </ul>
        Значення повертається у первісному вигляді без конвертації.
        Іншими словами, ланцюжок з АБО || повертає перше правдиве значення або останнє, якщо правдивого значення не знайдено.
    </p>
    <h3>&& (І)</h3>
    <p>
        Оператор І представлений двома амперсандами &&: <br>
        <code>result = a && b;</code>
        У класичному програмуванні І повертає true, якщо обидва оператори є правдивими, і false в іншому випадку: <br>
        <code>
            alert( true && true );   // true    <br>
            alert( false && true );  // false   <br>
            alert( true && false );  // false   <br>
            alert( false && false ); // false   <br>
        </code>
        Якщо у нас є декілька змінних розділених операндом && (І) то оператор && (І) робить наступне
        <ul>
            <li>Обчислює операнди зліва направо.</li>
            <li>Перетворює кожен операнд на булевий. Якщо результат false, зупиняється і повертає оригінальне значення того операнда.</li>
            <li>Якщо всі операнди були обчисленні (тобто усі були правдиві), повертає останній операнд.</li>
        </ul>
    </p>
    <h3>! (НЕ)</h3>
    <p>
        Булевий оператор НЕ представлений знаком оклику !.
        Оператор приймає один аргумент і виконує наступне:
        <ul>
            <li>Перетворює операнд на булевий тип: true/false.</li>
            <li>Повертає зворотне значення.</li>
        </ul>
        Подвійний НЕ !! іноді використовується для перетворення значення на булевий тип
    </p>
</section>